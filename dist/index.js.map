{"version":3,"sources":["../src/index.ts","../src/validators/fields/EntitiesField.ts","../src/validators/fields/BaseField.ts","../src/validators/fields/FieldConfig.ts","../src/validators/fields/FieldValidation.ts","../src/validators/fields/InputField.ts","../src/validators/fields/DropdownField.ts","../src/validators/fields/CheckboxField.ts","../src/validators/fields/FileField.ts","../src/validators/fields/DateField.ts","../src/validators/fields/CurrencyField.ts","../src/validators/fields/TitleField.ts","../src/validators/fields/ParagraphField.ts","../src/validators/fields/DividerField.ts","../src/validators/fields/ConsentField.ts","../src/validators/fields/SmartField.ts","../src/validators/fields/InformationCalloutField.ts","../src/validators/fields/FieldsGroup.ts","../src/validators/fields/ConditionalField.ts","../src/validators/fields/Field.ts","../src/lib/formEvaluation/utils/hasLogicalFields.ts","../src/utils/orderFields.ts","../src/constants/regex/range.ts","../src/utils/parsers/range.ts","../src/utils/parsers/country.ts","../src/utils/parsers/dates/epoch.ts","../src/utils/parsers/dates/ddmmyyyy.ts","../src/utils/parsers/dates/yyyymmdd.ts","../src/utils/parsers/dates/iso8601.ts","../src/utils/parsers/dates/timestampString.ts","../src/utils/parsers/dates/parser.ts","../src/utils/errors/RuleExecutionError.ts","../src/lib/predicate/utils/assertIsMatrix.ts","../src/utils/epochOrTodayToEpoch.ts","../src/validators/rules/predicate.ts","../src/validators/fieldType.ts","../src/lib/predicate/utils/calculateDayPeriod.ts","../src/lib/predicate/utils/calculateMonthPeriod.ts","../src/lib/predicate/utils/calculateWeekPeriod.ts","../src/lib/predicate/utils/calculateYearPeriod.ts","../src/lib/predicate/utils/calculateRelativePeriod.ts","../src/lib/predicate/utils/isDateInRelativePeriod.ts","../src/lib/predicate/utils/dateCompareAgainst.ts","../src/lib/predicate/utils/getRights.ts","../src/lib/predicate/executePredicate.ts","../src/lib/formEvaluation/utils/evaluateLogicalField.ts","../src/lib/formEvaluation/formEvaluation.ts","../src/constants/supportedLanguages.ts","../src/utils/isLocaleSupported.ts","../src/lib/translations/utils/translateNaceCodes.ts","../src/utils/cdn.ts","../src/lib/translations/translateFields.ts","../src/SpektrSdk.ts"],"sourcesContent":["export * from './SpektrSdk';\nexport { default } from './SpektrSdk';\n\nexport { type Field } from './validators/fields/Field';\nexport { type Form } from './validators/fields/Form';\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nimport { InputField } from './InputField';\nimport { DropdownField } from './DropdownField';\nimport { CheckboxField } from './CheckboxField';\nimport { FileField } from './FileField';\nimport { DateField } from './DateField';\nimport { CurrencyField } from './CurrencyField';\nimport { TitleField } from './TitleField';\nimport { ParagraphField } from './ParagraphField';\nimport { DividerField } from './DividerField';\nimport { ConsentField } from './ConsentField';\nimport { SmartField } from './SmartField';\nimport { InformationCalloutField } from './InformationCalloutField';\nimport { FieldsGroup } from './FieldsGroup';\nimport { ConditionalField } from './ConditionalField';\n\n// ? We are not using Field from './Field' because it will lead to circular dependency\nexport const EntitiesField = BaseField.merge(\n  z.object({\n    type: z.literal('entity'),\n    attributes: z.object({\n      label: z.string(),\n      name: z.string().optional(),\n      helperText: z.string().optional(),\n      buttonText: z.string(),\n      labelField: z.string().optional(),\n      internalId: z.string().optional(),\n      category: z.string().optional(),\n    }),\n    validation: z.array(FieldValidation).default([]),\n    form: z.object({\n      fields: z.record(\n        z.string(),\n        z.union([\n          DateField,\n          CurrencyField,\n          InputField,\n          DropdownField,\n          CheckboxField,\n          FileField,\n          DropdownField,\n          TitleField,\n          ParagraphField,\n          InformationCalloutField,\n          FieldsGroup,\n          DividerField,\n          ConsentField,\n          SmartField,\n          ConditionalField,\n        ])\n      ),\n      order: z.array(z.string()),\n    }),\n    relationType: z.string().optional(),\n  })\n);\n\nexport type EntitiesField = z.infer<typeof EntitiesField>;\n\nexport function isEntitiesField(field: unknown): field is EntitiesField {\n  return EntitiesField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { FieldConfig, FieldUiConfig } from './FieldConfig';\n\nexport const BaseField = z.object({\n  id: z.string(),\n  config: FieldConfig,\n  isStructured: z.boolean().default(false),\n  ui: FieldUiConfig.optional(),\n  customerFieldId: z.string().optional(),\n});\n\nexport type BaseField = z.infer<typeof BaseField>;\n","import { z } from 'zod';\n\nexport const FieldConfig = z.object({\n  spektrDataField: z.string(),\n  prefillDefaultValue: z.boolean().optional().default(true),\n  prefillSpektrDataField: z.string().optional(),\n  value: z.union([z.string(), z.number(), z.boolean(), z.null()]).optional(),\n  defaultValue: z\n    .union([z.string(), z.number(), z.boolean(), z.null()])\n    .optional(),\n});\n\nexport type FieldConfig = z.infer<typeof FieldConfig>;\n\nexport const FieldUiConfig = z.object({\n  style: z.object({\n    width: z.string().optional(),\n  }),\n});\n\nexport type FieldUiConfig = z.infer<typeof FieldUiConfig>;\n","import { z } from 'zod';\n\nexport const validationTypes = ['required', 'regex'] as const;\n\nexport const validationTypesEnum = z.enum(validationTypes);\n\nexport const RequiredFieldValidation = z.object({\n  type: z.literal('required'),\n  value: z.literal(true),\n  message: z.string(),\n});\n\nexport const RegexFieldValidation = z.object({\n  type: z.literal('regex'),\n  value: z.any(),\n  preset: z.string().optional(),\n  message: z.string(),\n});\n\nexport const DateFieldValidation = z.object({\n  type: z.literal('date'),\n  minimumAge: z.number().optional(),\n  maximumAge: z.number().optional(),\n  message: z.string(),\n});\n\nexport const FieldValidation = z.union([\n  RequiredFieldValidation,\n  RegexFieldValidation,\n  DateFieldValidation,\n]);\n\nexport type FieldValidation = z.infer<typeof FieldValidation>;\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const InputFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  type: z.string().optional().default('text'),\n  placeholder: z.string().optional(),\n  helperText: z.string().optional(),\n  countryField: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const InputField = BaseField.merge(\n  z.object({\n    type: z.literal('input'),\n    value: z.string().optional(),\n    attributes: InputFieldAttributes,\n    validation: z.array(FieldValidation).default([]),\n  })\n);\n\nexport type InputField = z.infer<typeof InputField>;\n\nexport function isInputField(field: unknown): field is InputField {\n  return InputField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const DropdownFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  placeholder: z.string().optional(),\n  options: z.array(z.object({ value: z.string(), label: z.string() })),\n  helperText: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const DropdownField = BaseField.merge(\n  z.object({\n    type: z.literal('select'),\n    attributes: DropdownFieldAttributes,\n    validation: z.array(FieldValidation),\n  })\n);\n\nexport type DropdownField = z.infer<typeof DropdownField>;\n\nexport function isDropdownField(field: unknown): field is DropdownField {\n  return DropdownField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const CheckboxFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  options: z.array(z.string()),\n  placeholder: z.string().optional(),\n  helperText: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const CheckboxField = BaseField.merge(\n  z.object({\n    type: z\n      .literal('radio')\n      .or(z.literal('checkbox'))\n      .or(z.literal('optionSwitch')),\n    attributes: CheckboxFieldAttributes,\n    validation: z.array(FieldValidation),\n  })\n);\n\nexport type CheckboxField = z.infer<typeof CheckboxField>;\n\nexport function isCheckboxField(field: unknown): field is CheckboxField {\n  return CheckboxField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const FileFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  fileType: z.string(),\n  placeholder: z.string().optional(),\n  helperText: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const FileField = BaseField.merge(\n  z.object({\n    type: z.literal('file'),\n    attributes: FileFieldAttributes,\n    validation: z.array(FieldValidation),\n  })\n);\n\nexport type FileField = z.infer<typeof FileField>;\n\nexport function isFileField(field: unknown): field is FileField {\n  return FileField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { InputField, InputFieldAttributes } from './InputField';\n\nexport const DateFieldAttributes = InputFieldAttributes.merge(\n  z.object({\n    type: z.literal('date'),\n    format: z.string().optional(),\n    minDate: z.string().optional(),\n    maxDate: z.string().optional(),\n  })\n);\n\nexport const DateField = InputField.merge(\n  z.object({\n    attributes: DateFieldAttributes,\n  })\n);\n\nexport type DateField = z.infer<typeof DateField>;\n\nexport function isDateField(field: unknown): field is DateField {\n  return DateField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { InputField, InputFieldAttributes } from './InputField';\n\nexport const CurrencyFieldAttributes = InputFieldAttributes.merge(\n  z.object({\n    type: z.literal('currency'),\n    currency: z\n      .object({\n        symbol: z.string(),\n        code: z.string(),\n      })\n      .optional(),\n  })\n);\n\nexport const CurrencyField = InputField.merge(\n  z.object({\n    attributes: CurrencyFieldAttributes,\n  })\n);\n\nexport type CurrencyField = z.infer<typeof CurrencyField>;\n\nexport function isCurrencyField(field: unknown): field is CurrencyField {\n  return CurrencyField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { FieldUiConfig } from './FieldConfig';\n\nexport const TitleField = z.object({\n  id: z.string(),\n  ui: FieldUiConfig.optional(),\n  type: z.literal('title'),\n  attributes: z.object({\n    content: z.string(),\n  }),\n});\n\nexport type TitleField = z.infer<typeof TitleField>;\n\nexport const isTitleField = (field: unknown): field is TitleField => {\n  return TitleField.safeParse(field).success;\n};\n","import { z } from 'zod';\n\nimport { FieldUiConfig } from './FieldConfig';\n\nexport const ParagraphField = z.object({\n  id: z.string(),\n  ui: FieldUiConfig.optional(),\n  type: z.literal('paragraph'),\n  attributes: z.object({\n    content: z.string(),\n  }),\n});\n\nexport type ParagraphField = z.infer<typeof ParagraphField>;\n\nexport const isParagraphField = (field: unknown): field is ParagraphField => {\n  return ParagraphField.safeParse(field).success;\n};\n","import { z } from 'zod';\n\nimport { FieldUiConfig } from './FieldConfig';\n\nexport const DividerField = z.object({\n  id: z.string(),\n  ui: FieldUiConfig.optional(),\n  type: z.literal('divider'),\n});\n\nexport type DividerField = z.infer<typeof DividerField>;\n\nexport const isDividerField = (field: unknown): field is DividerField => {\n  return DividerField.safeParse(field).success;\n};\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const ConsentFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const ConsentField = BaseField.merge(\n  z.object({\n    type: z.literal('consent'),\n    attributes: ConsentFieldAttributes,\n    validation: z.array(FieldValidation),\n  })\n);\n\nexport type ConsentField = z.infer<typeof ConsentField>;\n\nexport function isConsentField(field: unknown): field is ConsentField {\n  return ConsentField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\nimport { FieldValidation } from './FieldValidation';\n\nexport const SmartFieldAttributes = z.object({\n  label: z.string(),\n  name: z.string().optional(),\n  placeholder: z.string().optional(),\n  helperText: z.string().optional(),\n  internalId: z.string().optional(),\n});\n\nexport const SmartField = BaseField.merge(\n  z.object({\n    type: z.literal('smart'),\n    value: z.string().optional(),\n    attributes: SmartFieldAttributes,\n    validation: z.array(FieldValidation).default([]),\n  })\n);\n\nexport type SmartField = z.infer<typeof SmartField>;\n\nexport function isSmartField(field: unknown): field is SmartField {\n  return SmartField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { FieldUiConfig } from './FieldConfig';\n\nexport const InformationCalloutField = z.object({\n  id: z.string(),\n  ui: FieldUiConfig.optional(),\n  type: z.literal('informationCallout'),\n  attributes: z.object({\n    content: z.string(),\n  }),\n});\n\nexport type InformationCalloutField = z.infer<typeof InformationCalloutField>;\n\nexport const isInformationCalloutField = (\n  field: unknown\n): field is InformationCalloutField => {\n  return InformationCalloutField.safeParse(field).success;\n};\n","import { z } from 'zod';\n\nimport { FieldUiConfig } from './FieldConfig';\n\nexport const FieldsGroup = z.object({\n  id: z.string(),\n  ui: FieldUiConfig.optional(),\n  type: z.literal('fieldsGroup'),\n});\n\nexport type FieldsGroup = z.infer<typeof FieldsGroup>;\n\nexport const isFieldsGroup = (field: unknown): field is FieldsGroup => {\n  return FieldsGroup.safeParse(field).success;\n};\n","import { z } from 'zod';\n\nimport { BaseField } from './BaseField';\n\nimport { InputField } from './InputField';\nimport { DropdownField } from './DropdownField';\nimport { CheckboxField } from './CheckboxField';\nimport { FileField } from './FileField';\nimport { DateField } from './DateField';\nimport { CurrencyField } from './CurrencyField';\nimport { TitleField } from './TitleField';\nimport { ParagraphField } from './ParagraphField';\nimport { DividerField } from './DividerField';\nimport { ConsentField } from './ConsentField';\nimport { SmartField } from './SmartField';\nimport { InformationCalloutField } from './InformationCalloutField';\nimport { FieldsGroup } from './FieldsGroup';\nimport { FieldValidation } from './FieldValidation';\n\nconst outputTypes = ['show', 'hide'] as const;\n\nexport const ConditionOutput = z.enum(outputTypes);\nexport type ConditionOutput = z.infer<typeof ConditionOutput>;\n\nexport const ConditionalField = BaseField.merge(\n  z.object({\n    type: z.literal('conditional'),\n    validation: z.array(FieldValidation),\n    segment: z.any(), // Because \"Cannot access 'SegmentSchema' before initialization\"\n    output: ConditionOutput.optional().default('hide'),\n    form: z.object({\n      fields: z.record(\n        z.string(),\n        z.union([\n          DateField,\n          CurrencyField,\n          InputField,\n          DropdownField,\n          CheckboxField,\n          FileField,\n          DropdownField,\n          TitleField,\n          ParagraphField,\n          InformationCalloutField,\n          FieldsGroup,\n          DividerField,\n          ConsentField,\n          SmartField,\n        ])\n      ),\n      order: z.array(z.string()),\n    }),\n  })\n);\n\nexport type ConditionalField = z.infer<typeof ConditionalField>;\n\nexport function isConditionalField(field: unknown): field is ConditionalField {\n  return ConditionalField.safeParse(field).success;\n}\n","import { z } from 'zod';\n\nimport { InputField } from './InputField';\nimport { DropdownField } from './DropdownField';\nimport { CheckboxField } from './CheckboxField';\nimport { FileField } from './FileField';\nimport { DateField } from './DateField';\nimport { TitleField } from './TitleField';\nimport { EntitiesField } from './EntitiesField';\nimport { ParagraphField } from './ParagraphField';\nimport { DividerField } from './DividerField';\nimport { CurrencyField } from './CurrencyField';\nimport { ConsentField } from './ConsentField';\nimport { SmartField } from './SmartField';\nimport { InformationCalloutField } from './InformationCalloutField';\nimport { FieldsGroup } from './FieldsGroup';\nimport { ConditionalField } from './ConditionalField';\n\nexport const LogicalField = ConditionalField;\nexport type LogicalField = z.infer<typeof LogicalField>;\n\nexport function isLogicalField(field: unknown): field is LogicalField {\n  return LogicalField.safeParse(field).success;\n}\n\nexport const ReadOnlyField = z.union([\n  TitleField,\n  ParagraphField,\n  InformationCalloutField,\n  FieldsGroup,\n  DividerField,\n]);\nexport type ReadOnlyField = z.infer<typeof ReadOnlyField>;\n\nexport function isReadOnlyField(field: unknown): field is ReadOnlyField {\n  return ReadOnlyField.safeParse(field).success;\n}\n\n// ! When adding new fields, make sure to add them to the union in ./EntitiesField.ts\nexport const WritableField = z.union([\n  DateField,\n  CurrencyField,\n  InputField,\n  DropdownField,\n  CheckboxField,\n  FileField,\n  EntitiesField,\n  ConsentField,\n  SmartField,\n]);\nexport type WritableField = z.infer<typeof WritableField>;\n\nexport function isWritableField(field: unknown): field is WritableField {\n  return WritableField.safeParse(field).success;\n}\n\nexport const Field = z.union([ReadOnlyField, WritableField, LogicalField]);\nexport type Field = z.infer<typeof Field>;\n\nexport function isField(field: unknown): field is Field {\n  return Field.safeParse(field).success;\n}\n","import { isEntitiesField } from '../../../validators/fields/EntitiesField';\nimport { Field, isLogicalField } from '../../../validators/fields/Field';\n\n/**\n * @description\n *   Checks if the provided fields or entities contain any logical fields.\n * @param fields Form fields or entities to be checked\n *\n * @returns A boolean indicating whether any logical fields are present\n */\nexport function hasLogicalFields(fields: Record<string, Field>): boolean {\n  return Object.values(fields).some((field) => {\n    if (isLogicalField(field)) {\n      return true;\n    }\n\n    if (isEntitiesField(field)) {\n      return hasLogicalFields(field.form.fields);\n    }\n\n    return false;\n  });\n}\n","import { Field } from '../validators/fields/Field';\n\n/**\n * @description\n *    Orders the fields based on the provided order array.\n *  The function may be applied for the root form or for a nested form (entities).\n *\n * @param fields Fields to be ordered\n * @param order The order in which the fields should be arranged\n *\n * @returns An array of fields ordered according to the provided order\n */\nexport function orderFields(\n  fields: Record<string, Field>,\n  order: string[]\n): Field[] {\n  const orderedFields: Field[] = [];\n\n  if (\n    !Array.isArray(order) ||\n    order.length === 0 ||\n    !fields ||\n    Object.keys(fields).length === 0\n  ) {\n    return Object.values(fields);\n  }\n\n  order.forEach((fieldId) => {\n    if (fields[fieldId]) {\n      orderedFields.push(fields[fieldId]);\n    }\n  });\n\n  return orderedFields;\n}\n","export const rangeRegex =\n  /^\\[\\s{0,10}(-?\\d+|\\w+)?\\s{0,10},\\s{0,10}(-?\\d+|\\w+)?\\s{0,10}\\]$/;\n","import { rangeRegex } from '../../constants/regex';\n\nexport const parseRange = (range: string | undefined): [string, string] => {\n  const match = range?.match(rangeRegex);\n\n  if (!match) return ['', ''];\n\n  const min = match[1]?.trim() || '';\n  const max = match[2]?.trim() || '';\n\n  return [min, max];\n};\n","import * as iso from 'iso-3166-1';\n\nimport { ParsedCountry } from '../../types/ParsedCountry';\n\nexport const parseCountry = (\n  countryIdentifier: string\n): ParsedCountry | undefined => {\n  if (!countryIdentifier || countryIdentifier.length < 2) return undefined;\n\n  const identifierType =\n    countryIdentifier.length === 2\n      ? 'iso2'\n      : countryIdentifier.length === 3\n        ? 'iso3'\n        : 'name';\n\n  let countryInfo = undefined;\n  switch (identifierType) {\n    case 'name':\n      countryInfo = iso.whereCountry(countryIdentifier);\n      break;\n    case 'iso2':\n      countryInfo = iso.whereAlpha2(countryIdentifier);\n      break;\n    case 'iso3':\n      countryInfo = iso.whereAlpha3(countryIdentifier);\n      break;\n  }\n\n  if (!countryInfo) return undefined;\n\n  return {\n    isoAlpha2: countryInfo.alpha2,\n    isoAlpha3: countryInfo.alpha3,\n    name: countryInfo.country,\n  };\n};\n","import { DateParserFunction } from './types';\n\nexport const parseEpochDate: DateParserFunction = (date: string) => {\n  const regex = /^-?\\d+$/;\n  if (regex.test(date)) {\n    const ms = Number(date) * 1000; // JS date expects epoch timestamps to be meassured in milliseconds so we multiply by 1000\n    return new Date(ms);\n  }\n\n  return undefined;\n};\n","import { DateParserFunction } from './types';\n\nexport const parseDdMmYyyyDate: DateParserFunction = (date: string) => {\n  const regex = /^(0[1-9]|[12][0-9]|3[01])[-/](0[1-9]|1[012])[-/](\\d{4})$/;\n  const match = date.match(regex);\n\n  if (match) {\n    const [_, dayString, monthString, yearString] = match;\n    if (!dayString || !monthString || !yearString) return undefined;\n    const day = parseInt(dayString);\n    const month = parseInt(monthString) - 1; // JS months are 0-indexed\n    const year = parseInt(yearString);\n\n    const utcDate = new Date(Date.UTC(year, month, day));\n\n    // verify that the year/month/date match as expected. This is to catch errors like parsing 29/02/2023 (valid w.r.t the regex, but still not a valid date)\n    if (\n      utcDate.getFullYear() === year &&\n      utcDate.getMonth() === month &&\n      utcDate.getDate() === day\n    ) {\n      return utcDate;\n    }\n  }\n\n  return undefined;\n};\n","import { DateParserFunction } from './types';\n\nexport const parseYyyyMmDdDate: DateParserFunction = (date: string) => {\n  const regex = /^(\\d{4})[-/](0[1-9]|1[012])[-/](0[1-9]|[12][0-9]|3[01])$/;\n\n  const match = date.match(regex);\n\n  if (match) {\n    const [_, yearString, monthString, dayString] = match;\n    if (!dayString || !monthString || !yearString) return undefined;\n    const year = parseInt(yearString);\n    const month = parseInt(monthString) - 1; // JS months are 0-indexed\n    const day = parseInt(dayString);\n\n    const date = new Date(year, month, day);\n\n    // Check if the date is valid\n    if (\n      date.getFullYear() === year &&\n      date.getMonth() === month &&\n      date.getDate() === day\n    ) {\n      return date;\n    }\n  }\n  return undefined;\n};\n","import { parseISO } from 'date-fns';\n\nimport { DateParserFunction } from './types';\n\nexport const parseIso8601Date: DateParserFunction = (date: string) => {\n  const hasTimezone = /[+-]\\d\\d:\\d\\d$|Z$/.test(date);\n\n  // If no timezone information is present, append 'Z' to treat it as UTC\n  const dateInUtc = hasTimezone ? date : `${date}Z`;\n\n  const parsed = parseISO(dateInUtc);\n  if (isNaN(parsed.getTime())) return undefined;\n\n  return parsed;\n};\n","import { DateParserFunction } from './types';\n\nexport const parseTimestampString: DateParserFunction = (date: string) => {\n  // Unix Timestamp (seconds)\n  if (/^\\d{10}$/.test(date)) {\n    return new Date(parseInt(date, 10) * 1000);\n  }\n  // Unix Timestamp (milliseconds)\n  else if (/^\\d{13}$/.test(date)) {\n    return new Date(parseInt(date, 10));\n  }\n\n  return undefined;\n};\n","import { parseEpochDate } from './epoch';\n\nimport { parseDdMmYyyyDate } from './ddmmyyyy';\nimport { parseYyyyMmDdDate } from './yyyymmdd';\nimport { parseIso8601Date } from './iso8601';\nimport { parseTimestampString } from './timestampString';\n\nimport { DateParserFunction } from './types';\n\nexport const parseDate: DateParserFunction = (date: string) => {\n  const parsers: DateParserFunction[] = [\n    parseTimestampString,\n    parseDdMmYyyyDate,\n    parseYyyyMmDdDate,\n    parseIso8601Date,\n    parseEpochDate,\n  ];\n\n  for (const parser of parsers) {\n    const parsed = parser(date);\n\n    if (parsed) return parsed;\n  }\n\n  return undefined;\n};\n\nexport function parseDateToTimestamp(value: string | number | boolean): number {\n  if (typeof value === 'boolean') {\n    throw new Error(`Value ${value} can not be parsed to a date`);\n  }\n\n  if (typeof value === 'number') {\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n      throw new Error(`Value ${value} can not be parsed to a date`);\n    }\n\n    return ensureMilliseconds(value);\n  }\n\n  const parsedDate = parseDate(value);\n\n  if (parsedDate === undefined) {\n    throw new Error(`Value ${value} can not be parsed to a date`);\n  }\n\n  return parsedDate.getTime();\n}\n\nfunction ensureMilliseconds(timestamp: number) {\n  if (timestamp < 10000000000) {\n    return timestamp * 1000;\n  }\n  return timestamp;\n}\n","export class RuleExecutionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'RuleExecutionError';\n  }\n}\n","import { RuleExecutionError } from '../../../utils/errors';\n\nimport { Matrix } from '../../../types/Matrix';\n\nexport function assertIsMatrix(matrix: unknown): asserts matrix is Matrix {\n  if (!Array.isArray(matrix))\n    throw new RuleExecutionError(\n      `Rule Execution failed. Expected matrix to be of type 'array' but received '${matrix}' of type '${typeof matrix}'`\n    );\n\n  for (const row of matrix) {\n    if (!Array.isArray(row))\n      throw new RuleExecutionError(\n        `Rule Execution failed. Expected row in matrix to be of type 'array' but received '${row}' of type '${typeof row}'`\n      );\n    for (const cell of row) {\n      if (typeof cell !== 'string')\n        throw new RuleExecutionError(\n          `Rule Execution failed. Expected cell in matrix row to be of type 'string' but received '${cell}' of type '${typeof cell}'`\n        );\n    }\n  }\n}\n","export function epochOrTodayToEpoch(epochOrToday: number | string | '@today') {\n  if (epochOrToday === '@today') {\n    // compare against the current date (set to midnight)\n    return new Date().setUTCHours(0, 0, 0, 0);\n  } else {\n    return new Date(Number(epochOrToday)).setUTCHours(0, 0, 0, 0);\n  }\n}\n","import { z, ZodRawShape, ZodType } from 'zod';\n\nimport { rangeRegex } from '../../constants/regex';\n\nimport { SpektrFieldType } from '../fieldType';\n\n// We need to explicitly define the boolean to help zod resolve the circular dependency between 'predicateSchema' and 'booleanPredicateSchema'.\n// Otherwise zod cannot infer the type.\nexport const booleanPredicateSchema: z.ZodObject<\n  ZodRawShape,\n  'strip',\n  ZodType<{\n    operator: 'and' | 'or';\n    groupRoot?: boolean;\n    type: SpektrFieldType;\n    left: z.infer<typeof predicateSchema>;\n    right: z.infer<typeof predicateSchema>;\n    rightMode?: 'literal' | 'variable';\n  }>,\n  {\n    operator: 'and' | 'or';\n    groupRoot?: boolean;\n    type: SpektrFieldType;\n    left: z.infer<typeof predicateSchema>;\n    right: z.infer<typeof predicateSchema>;\n    rightMode?: 'literal' | 'variable';\n  }\n> = z.object({\n  operator: z.enum(['and', 'or']),\n  groupRoot: z.boolean().optional(),\n  type: SpektrFieldType,\n  left: z.lazy(() => predicateSchema),\n  right: z.lazy(() => predicateSchema),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n});\n\nexport const isBooleanPredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof booleanPredicateSchema> => {\n  return booleanPredicateSchema.safeParse(predicate).success;\n};\n\nexport const equalityPredicateSchema = z.object({\n  operator: z.enum(['equals', 'not_equals']),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.union([z.string(), z.number(), z.boolean()]),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n});\n\nexport const isEqualityPredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof equalityPredicateSchema> => {\n  return equalityPredicateSchema.safeParse(predicate).success;\n};\n\nexport const inequalityPredicateSchema = z.object({\n  operator: z.enum(['greater_than', 'less_than']),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.string().or(z.number()),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n});\n\nexport const isInequalityPredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof inequalityPredicateSchema> => {\n  return inequalityPredicateSchema.safeParse(predicate).success;\n};\n\nexport const rangePredicateSchema = z.object({\n  operator: z.enum(['between', 'outside']),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.string().regex(rangeRegex),\n  rightLowerboundMode: z\n    .enum(['literal', 'variable'])\n    .default('literal')\n    .optional(),\n  rightUpperboundMode: z\n    .enum(['literal', 'variable'])\n    .default('literal')\n    .optional(),\n});\n\nexport const isRangePredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof rangePredicateSchema> => {\n  return rangePredicateSchema.safeParse(predicate).success;\n};\n\nexport const IsRelativeToDatePositions = {\n  THIS: 'this' as const,\n  NEXT: 'next' as const,\n  PAST: 'past' as const,\n} as const;\n\nexport const IsRelativeToDateScopes = {\n  DAY: 'day' as const,\n  WEEK: 'week' as const,\n  MONTH: 'month' as const,\n  YEAR: 'year' as const,\n} as const;\n\nexport type IsRelativeToDatePosition =\n  (typeof IsRelativeToDatePositions)[keyof typeof IsRelativeToDatePositions];\nexport type IsRelativeToDateScope =\n  (typeof IsRelativeToDateScopes)[keyof typeof IsRelativeToDateScopes];\n\nexport const datePositionSchema = z.enum([\n  IsRelativeToDatePositions.THIS,\n  IsRelativeToDatePositions.NEXT,\n  IsRelativeToDatePositions.PAST,\n]);\n\nexport const dateScopeSchema = z.enum([\n  IsRelativeToDateScopes.DAY,\n  IsRelativeToDateScopes.WEEK,\n  IsRelativeToDateScopes.MONTH,\n  IsRelativeToDateScopes.YEAR,\n]);\n\nexport const dateAfterBeforeSchema = z.object({\n  operator: z.enum([\n    'is_after',\n    'is_before',\n    'is_on_or_after',\n    'is_on_or_before',\n  ]),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.string().or(z.number()),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n});\n\nexport const dateRelativeToTodaySchema = z.object({\n  operator: z.literal('is_relative_to_today'),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.string().or(z.number()).optional(),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n  isRelativeConfig: z.object({\n    position: datePositionSchema,\n    scope: dateScopeSchema,\n    quantity: z.number(),\n  }),\n});\n\nexport const dateComparisonPredicateSchema = z.discriminatedUnion('operator', [\n  dateAfterBeforeSchema,\n  dateRelativeToTodaySchema,\n]);\n\nexport const isDateComparisonPredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof dateComparisonPredicateSchema> => {\n  return dateComparisonPredicateSchema.safeParse(predicate).success;\n};\n\nexport const existencePredicateSchema = z.object({\n  operator: z.enum(['is_empty', 'is_not_empty']),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.undefined().optional(),\n});\n\nexport const matrixPredicateSchema = z.object({\n  operator: z.enum(['is_in', 'is_not_in']),\n  type: z.literal('matrix'),\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.array(z.array(z.string())),\n});\n\nexport const noOpPredicateSchema = z.object({\n  operator: z.literal('noOp'),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.undefined(),\n  right: z.undefined(),\n});\n\nexport const containsPredicateSchema = z.object({\n  operator: z.enum(['contains', 'not_contains']),\n  type: SpektrFieldType,\n  groupRoot: z.boolean().optional(),\n  left: z.string(),\n  right: z.union([z.string(), z.array(z.string())]),\n  rightMode: z.enum(['literal', 'variable']).default('literal').optional(),\n});\nexport const isContainsPredicate = (\n  predicate: z.infer<typeof predicateSchema>\n): predicate is z.infer<typeof containsPredicateSchema> => {\n  return containsPredicateSchema.safeParse(predicate).success;\n};\n\nexport const predicateSchema = z.union([\n  booleanPredicateSchema,\n  equalityPredicateSchema,\n  inequalityPredicateSchema,\n  rangePredicateSchema,\n  dateComparisonPredicateSchema,\n  existencePredicateSchema,\n  matrixPredicateSchema,\n  noOpPredicateSchema,\n  containsPredicateSchema,\n]);\n\nexport type Predicate = z.infer<typeof predicateSchema>;\n","import { z } from 'zod';\n\nexport const SpektrFieldType = z.enum([\n  'string',\n  'number',\n  'date',\n  'country',\n  'boolean',\n  'file',\n  'matrix',\n]);\n\nexport type SpektrFieldType = z.infer<typeof SpektrFieldType>;\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDatePositions,\n} from '../../../validators/rules/predicate';\n\nexport const calculateDayPeriod = (\n  today: Date,\n  position: IsRelativeToDatePosition,\n  quantity = 1\n): { start: number; end: number } => {\n  const todayYear = today.getFullYear();\n  const todayMonth = today.getMonth();\n  const todayDate = today.getDate();\n\n  if (position === IsRelativeToDatePositions.THIS) {\n    return {\n      start: today.getTime(),\n      end: today.getTime(),\n    };\n  } else if (position === IsRelativeToDatePositions.PAST) {\n    // For \"Past N days\", we want days [Today-N, Today-1]\n    const pastDayStart = new Date(\n      Date.UTC(todayYear, todayMonth, todayDate - quantity)\n    );\n\n    const pastDayEnd = new Date(Date.UTC(todayYear, todayMonth, todayDate - 1));\n\n    return {\n      start: pastDayStart.getTime(),\n      end: pastDayEnd.getTime(),\n    };\n  } else if (position === IsRelativeToDatePositions.NEXT) {\n    // For \"Next N days\", we want days [Today+1, Today+N]\n    const nextDayStart = new Date(\n      Date.UTC(todayYear, todayMonth, todayDate + 1)\n    );\n\n    const nextDayEnd = new Date(\n      Date.UTC(todayYear, todayMonth, todayDate + quantity)\n    );\n\n    return {\n      start: nextDayStart.getTime(),\n      end: nextDayEnd.getTime(),\n    };\n  }\n\n  throw new Error(`Unsupported position: ${position}`);\n};\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDatePositions,\n} from '../../../validators/rules/predicate';\n\nexport const calculateMonthPeriod = (\n  today: Date,\n  position: IsRelativeToDatePosition,\n  quantity = 1\n): { start: number; end: number } => {\n  const currentYear = today.getFullYear();\n  const currentMonth = today.getMonth(); // 0-11\n\n  // Determine month offsets and day values based on position\n  let startMonthOffset = 0;\n  let endMonthOffset = 0;\n  const startDay = 1;\n  const endDay = 0; // 0 means last day of previous month\n\n  if (position === IsRelativeToDatePositions.THIS) {\n    startMonthOffset = 0;\n    endMonthOffset = 1;\n  } else if (position === IsRelativeToDatePositions.PAST) {\n    startMonthOffset = -quantity;\n    endMonthOffset = 0;\n  } else if (position === IsRelativeToDatePositions.NEXT) {\n    startMonthOffset = 1;\n    endMonthOffset = quantity + 1;\n  } else {\n    throw new Error(`Unsupported position: ${position}`);\n  }\n\n  const start = new Date(\n    Date.UTC(currentYear, currentMonth + startMonthOffset, startDay)\n  ).getTime();\n\n  const end = new Date(\n    Date.UTC(currentYear, currentMonth + endMonthOffset, endDay)\n  ).getTime();\n\n  return { start, end };\n};\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDatePositions,\n} from '../../../validators/rules/predicate';\n\nexport const calculateWeekPeriod = (\n  today: Date,\n  position: IsRelativeToDatePosition,\n  quantity = 1\n): { start: number; end: number } => {\n  const todayYear = today.getFullYear();\n  const todayMonth = today.getMonth();\n  const todayDate = today.getDate(); //Day of the month (1-31)\n  const currentDay = today.getDay(); //Day of the week (0-6), 0 is Sunday\n\n  const sunOfWeek = todayDate - currentDay; //\"rewind\" to the Sunday of the current week\n\n  // Determine start and end offsets based on position\n  let startOffset = 0;\n  let endOffset = 0;\n\n  if (position === IsRelativeToDatePositions.THIS) {\n    startOffset = 0;\n    endOffset = 6;\n  } else if (position === IsRelativeToDatePositions.PAST) {\n    startOffset = -7 * quantity;\n    endOffset = -1;\n  } else if (position === IsRelativeToDatePositions.NEXT) {\n    startOffset = 7;\n    endOffset = 7 * quantity + 6;\n  } else {\n    throw new Error(`Unsupported position: ${position}`);\n  }\n\n  const start = new Date(\n    Date.UTC(todayYear, todayMonth, sunOfWeek + startOffset)\n  ).getTime();\n  const end = new Date(\n    Date.UTC(todayYear, todayMonth, sunOfWeek + endOffset)\n  ).getTime();\n\n  return { start, end };\n};\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDatePositions,\n} from '../../../validators/rules/predicate';\n\nexport const calculateYearPeriod = (\n  today: Date,\n  position: IsRelativeToDatePosition,\n  quantity = 1\n): { start: number; end: number } => {\n  const currentYear = today.getFullYear();\n\n  // Determine year offsets based on position\n  let startYearOffset = 0;\n  let endYearOffset = 0;\n\n  if (position === IsRelativeToDatePositions.THIS) {\n    startYearOffset = 0;\n    endYearOffset = 0;\n  } else if (position === IsRelativeToDatePositions.PAST) {\n    startYearOffset = -quantity;\n    endYearOffset = -1;\n  } else if (position === IsRelativeToDatePositions.NEXT) {\n    startYearOffset = 1;\n    endYearOffset = quantity;\n  } else {\n    throw new Error(`Unsupported position: ${position}`);\n  }\n\n  const start = new Date(\n    Date.UTC(currentYear + startYearOffset, 0, 1)\n  ).getTime();\n\n  const end = new Date(Date.UTC(currentYear + endYearOffset, 11, 31)).getTime();\n\n  return { start, end };\n};\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDateScope,\n  IsRelativeToDateScopes,\n} from '../../../validators/rules/predicate';\n\nimport { calculateDayPeriod } from './calculateDayPeriod';\nimport { calculateMonthPeriod } from './calculateMonthPeriod';\nimport { calculateWeekPeriod } from './calculateWeekPeriod';\nimport { calculateYearPeriod } from './calculateYearPeriod';\n\nexport const calculateRelativePeriod = (\n  position: IsRelativeToDatePosition,\n  scope: IsRelativeToDateScope,\n  quantity = 1\n): { start: number; end: number } => {\n  if (quantity <= 0) {\n    quantity = 1;\n  }\n\n  //normalize to midnight UTC for consistent comparison\n  const now = new Date();\n  const today = new Date(\n    Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())\n  );\n\n  switch (scope) {\n    case IsRelativeToDateScopes.DAY:\n      return calculateDayPeriod(today, position, quantity);\n    case IsRelativeToDateScopes.WEEK:\n      return calculateWeekPeriod(today, position, quantity);\n    case IsRelativeToDateScopes.MONTH:\n      return calculateMonthPeriod(today, position, quantity);\n    case IsRelativeToDateScopes.YEAR:\n      return calculateYearPeriod(today, position, quantity);\n    default:\n      throw new Error(`Unsupported time scope: ${scope}`);\n  }\n};\n","import {\n  IsRelativeToDatePosition,\n  IsRelativeToDateScope,\n} from '../../../validators/rules/predicate';\n\nimport { calculateRelativePeriod } from './calculateRelativePeriod';\n\nexport type DateQuantityConfig = {\n  position: IsRelativeToDatePosition;\n  scope: IsRelativeToDateScope;\n  quantity?: number;\n};\n\nexport const isDateInRelativePeriod = (\n  dateEpoch: number,\n  config: DateQuantityConfig\n): boolean => {\n  const { position, scope, quantity = 1 } = config;\n  const { start, end } = calculateRelativePeriod(position, scope, quantity);\n\n  // Normalize input date to midnight UTC\n  const date = new Date(dateEpoch);\n  const normalizedDate = Date.UTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate()\n  );\n\n  return normalizedDate >= start && normalizedDate <= end;\n};\n","import { epochOrTodayToEpoch } from '../../../utils/epochOrTodayToEpoch';\nimport {\n  isDateInRelativePeriod,\n  type DateQuantityConfig,\n} from './isDateInRelativePeriod';\n\nexport const dateCompareAgainst = (leftEpoch: number) => {\n  leftEpoch = new Date(leftEpoch).setUTCHours(0, 0, 0, 0);\n\n  const isSameDate = (rightEpochOrToday: number | string | '@today') => {\n    const rightEpoch = epochOrTodayToEpoch(rightEpochOrToday);\n\n    return leftEpoch === rightEpoch;\n  };\n\n  const isAfterDate = (rightEpochOrToday: number | string | '@today') => {\n    const rightEpoch = epochOrTodayToEpoch(rightEpochOrToday);\n\n    return leftEpoch > rightEpoch;\n  };\n\n  const isBeforeDate = (rightEpochOrToday: number | string | '@today') => {\n    const rightEpoch = epochOrTodayToEpoch(rightEpochOrToday);\n\n    return leftEpoch < rightEpoch;\n  };\n\n  const isOnOrBeforeDate = (rightEpochOrToday: number | string | '@today') => {\n    const rightEpoch = epochOrTodayToEpoch(rightEpochOrToday);\n\n    return leftEpoch <= rightEpoch;\n  };\n\n  const isOnOrAfterDate = (rightEpochOrToday: number | string | '@today') => {\n    const rightEpoch = epochOrTodayToEpoch(rightEpochOrToday);\n\n    return leftEpoch >= rightEpoch;\n  };\n\n  const isInRelativePeriod = (isRelativeConfig: DateQuantityConfig) => {\n    return isDateInRelativePeriod(leftEpoch, isRelativeConfig);\n  };\n\n  return {\n    isSameDate,\n    isAfterDate,\n    isBeforeDate,\n    isOnOrBeforeDate,\n    isOnOrAfterDate,\n    isInRelativePeriod,\n  };\n};\n","import { parseRange } from '../../../utils/parsers';\nimport { RuleExecutionError } from '../../../utils/errors';\n\nimport { SpektrData } from '../../../validators/data';\nimport { Predicate } from '../../../validators/rules/predicate';\nimport { Bounds } from '../../../types/Bounds';\nimport { Matrix } from '../../../types/Matrix';\n\nexport const getRights = (\n  predicate: Predicate,\n  subs: SpektrData\n): Matrix | Bounds | string | number | boolean | string[] | undefined => {\n  switch (predicate.operator) {\n    case 'noOp':\n      return undefined;\n    case 'is_empty':\n    case 'is_not_empty':\n      return undefined;\n    case 'between':\n    case 'outside': {\n      let [min, max]: [string | number, string | number] = parseRange(\n        predicate.right\n      );\n\n      if (predicate.rightLowerboundMode === 'variable') {\n        min = Number(subs[String(min)]);\n      }\n\n      if (predicate.rightUpperboundMode === 'variable') {\n        max = Number(subs[String(max)]);\n      }\n      return [Number(min), Number(max)];\n    }\n\n    case 'is_in':\n    case 'is_not_in':\n      return predicate.right;\n    case 'is_relative_to_today':\n      return undefined;\n    case 'is_after':\n    case 'is_before':\n    case 'is_on_or_after':\n    case 'is_on_or_before':\n    case 'equals':\n    case 'not_equals':\n    case 'less_than':\n    case 'greater_than':\n    case 'and':\n    case 'or': {\n      if (typeof predicate.right === 'object')\n        throw new RuleExecutionError(\n          `Rule Execution failed for operator '${predicate.operator}' with right-hand value: ${JSON.stringify(predicate.right)}`\n        );\n      const right =\n        predicate.rightMode === 'variable'\n          ? subs[String(predicate.right)]\n          : predicate.right;\n      return right ?? undefined;\n    }\n\n    case 'contains':\n    case 'not_contains':\n      if (Array.isArray(predicate.right)) {\n        return predicate.right;\n      }\n      if (predicate.rightMode === 'variable') {\n        return subs[String(predicate.right)] ?? undefined;\n      }\n\n      return predicate.right;\n  }\n};\n","import { parseCountry, parseDateToTimestamp } from '../../utils/parsers';\nimport { RuleExecutionError } from '../../utils/errors';\n\nimport { SpektrData } from '../../validators/data';\nimport { Predicate } from '../../validators/rules/predicate';\n\nimport { assertIsMatrix } from './utils/assertIsMatrix';\nimport { dateCompareAgainst } from './utils/dateCompareAgainst';\nimport { getRights } from './utils/getRights';\n\nexport function executePredicate(\n  predicate: Predicate,\n  leftSubs: SpektrData,\n  rightSubs: SpektrData\n): boolean {\n  if (predicate.operator === 'noOp') {\n    return true;\n  }\n  if (predicate.operator === 'and') {\n    const leftEvaluated = executePredicate(predicate.left, leftSubs, rightSubs);\n    const rightEvaluated = executePredicate(\n      predicate.right,\n      leftSubs,\n      rightSubs\n    );\n    return leftEvaluated && rightEvaluated;\n  }\n\n  if (predicate.operator === 'or') {\n    const leftEvaluated = executePredicate(predicate.left, leftSubs, rightSubs);\n    const rightEvaluated = executePredicate(\n      predicate.right,\n      leftSubs,\n      rightSubs\n    );\n    return leftEvaluated || rightEvaluated;\n  }\n\n  if (typeof predicate.left !== 'string')\n    throw new RuleExecutionError(\n      `Rule Execution failed. Left operand of leaf rule must be of type string but received left operand '${predicate.left\n      }' of type '${typeof predicate.left}'`\n    );\n\n  const left = leftSubs[predicate.left];\n  if (left === undefined && predicate.operator !== 'is_empty') return false;\n\n  const rights = getRights(predicate, rightSubs);\n\n  if (\n    predicate.type === 'date' &&\n    predicate.operator !== 'is_empty' &&\n    predicate.operator !== 'is_not_empty' &&\n    (typeof rights === 'number' || typeof rights === 'string')\n  ) {\n    if (!left)\n      throw new RuleExecutionError(\n        `Rule Execution failed. Left operand of a date-rule with operator '${predicate.operator}' cannot be empty.'`\n      );\n\n    const leftEpoch = parseDateToTimestamp(left);\n    const spektrFieldDate = dateCompareAgainst(leftEpoch);\n\n    if (predicate.operator === 'is_after') {\n      return spektrFieldDate.isAfterDate(rights);\n    }\n\n    if (predicate.operator === 'is_before') {\n      return spektrFieldDate.isBeforeDate(rights);\n    }\n\n    if (predicate.operator === 'equals') {\n      return spektrFieldDate.isSameDate(rights);\n    }\n\n    if (predicate.operator === 'not_equals') {\n      return !spektrFieldDate.isSameDate(rights);\n    }\n    if (predicate.operator === 'is_on_or_before') {\n      return spektrFieldDate.isOnOrBeforeDate(rights);\n    }\n    if (predicate.operator === 'is_on_or_after') {\n      return spektrFieldDate.isOnOrAfterDate(rights);\n    }\n  }\n\n  if (predicate.operator === 'is_empty') {\n    return left === null || left === undefined;\n  }\n\n  if (predicate.operator === 'is_not_empty') {\n    return left !== null || left === undefined;\n  }\n\n  if (\n    predicate.type === 'date' &&\n    predicate.operator === 'is_relative_to_today'\n  ) {\n    if (!left || !predicate.isRelativeConfig)\n      throw new RuleExecutionError(\n        `Rule Execution failed. Left operand and/or isRelativeConfig cannot be empty.`\n      );\n    const leftEpoch = parseDateToTimestamp(left);\n    const spektrFieldDate = dateCompareAgainst(leftEpoch);\n    return spektrFieldDate.isInRelativePeriod(predicate.isRelativeConfig);\n  }\n\n  if (predicate.type === 'country' && Array.isArray(rights)) {\n    // Compare substituted left side against right-side. Both sides can be either\n    // - full country name (e.g Denmark)\n    // - iso2: (e.g DK)\n    // - iso3: (e.g DNK)\n    //right side of a country rule can be a plain country name, a country list or a risk matrix.\n\n    const leftCountry = parseCountry(String(left));\n\n    if (leftCountry) {\n      const match = rights.some((right) => {\n        const rightCountry = parseCountry(String(right));\n        return (\n          leftCountry.isoAlpha2 === rightCountry?.isoAlpha2 ||\n          leftCountry.name === rightCountry?.name\n        );\n      });\n\n      if (predicate.operator === 'contains') return match;\n      if (predicate.operator === 'not_contains') return !match;\n    }\n  }\n\n  if (predicate.operator === 'contains' && Array.isArray(rights)) {\n    let arrayLeft;\n    try {\n      arrayLeft = JSON.parse(String(left));\n    } catch (_e) {\n      // if it fails it means left is not a valid JSON string, so we can proceed with the assumption that it is a string\n      arrayLeft = [left];\n    }\n\n    if (Array.isArray(arrayLeft)) {\n      if (arrayLeft.length === 0) return false;\n\n      const rightsSet = new Set(\n        rights.map((right) =>\n          typeof right === 'string' ? right.toLowerCase() : right\n        )\n      );\n\n      return arrayLeft.some((leftItem) => {\n        if (typeof leftItem !== 'string') {\n          throw new RuleExecutionError(\n            `Rule Execution failed. Left operand of a contains-rule must be of type string but received '${leftItem}' of type '${typeof leftItem}'`\n          );\n        }\n        return rightsSet.has(leftItem.toLowerCase());\n      });\n    }\n  }\n\n  if (predicate.operator === 'not_contains' && Array.isArray(rights)) {\n    let arrayLeft;\n    try {\n      arrayLeft = JSON.parse(String(left));\n    } catch (_e) {\n      // if it fails it means left is not a valid JSON string, so we can proceed with the assumption that it is a string\n      arrayLeft = [left];\n    }\n\n    if (Array.isArray(arrayLeft)) {\n      if (arrayLeft.length === 0) return true;\n\n      const rightsSet = new Set(\n        rights.map((right) =>\n          typeof right === 'string' ? right.toLowerCase() : right\n        )\n      );\n\n      return arrayLeft.every((leftItem) => {\n        if (typeof leftItem !== 'string') {\n          throw new RuleExecutionError(\n            `Rule Execution failed. Left operand of a not_contains-rule must be of type string but received '${leftItem}' of type '${typeof leftItem}'`\n          );\n        }\n        return !rightsSet.has(leftItem.toLowerCase());\n      });\n    }\n  }\n\n  if (predicate.operator === 'contains' && typeof rights === 'string') {\n    try {\n      const parsedLeft = JSON.parse(String(left));\n      if (Array.isArray(parsedLeft)) {\n        throw new RuleExecutionError(\n          'Rule Execution failed. Expected left to be of type string for a contains rule with rights of type string, but received an array'\n        );\n      }\n    } catch (_e) {\n      // If JSON.parse fails, it means left is not a valid JSON string, so we can proceed\n    }\n\n    return !!left\n      ?.toLocaleString()\n      .toLowerCase()\n      .includes(rights.toLowerCase());\n  }\n\n  if (predicate.operator === 'not_contains' && typeof rights === 'string') {\n    try {\n      const parsedLeft = JSON.parse(String(left));\n      if (Array.isArray(parsedLeft)) {\n        throw new RuleExecutionError(\n          'Rule Execution failed. Expected left to be of type string for a contains rule with rights of type string, but received an array'\n        );\n      }\n    } catch (_e) {\n      // If JSON.parse fails, it means left is not a valid JSON string, so we can proceed\n    }\n\n    return !left?.toLocaleString().toLowerCase().includes(rights.toLowerCase());\n  }\n\n  if (predicate.type === 'country' && typeof rights === 'string') {\n    // Compare substituted left side against right-side. Both sides can be either\n    // - full country name (e.g Denmark)\n    // - iso2: (e.g DK)\n    // - iso3: (e.g DNK)\n    //right side of a country rule can be a plain country name, a country list or a risk matrix.\n\n    const rightCountry = parseCountry(rights);\n    const leftCountry = parseCountry(String(left));\n\n    if (leftCountry && rightCountry) {\n      const match = leftCountry.isoAlpha2 === rightCountry.isoAlpha2;\n      if (predicate.operator === 'equals') return match;\n      if (predicate.operator === 'not_equals') return !match;\n    }\n  }\n\n  if (predicate.operator === 'equals') {\n    if (typeof left === 'string' && typeof rights === 'string') {\n      return left.toLowerCase() === rights.toLowerCase();\n    }\n\n    const normalizedLeft =\n      typeof left === 'string' && predicate.type === 'boolean'\n        ? left.toLowerCase() === 'true'\n        : left;\n    const normalizedRights =\n      typeof rights === 'string' && predicate.type === 'boolean'\n        ? rights.toLowerCase() === 'true'\n        : rights;\n\n    return normalizedLeft == normalizedRights && !Number.isNaN(normalizedLeft);\n  }\n\n  if (predicate.operator === 'not_equals') {\n    if (typeof left === 'string' && typeof rights === 'string') {\n      return left.toLowerCase() !== rights.toLowerCase();\n    }\n    const normalizedLeft =\n      typeof left === 'string' && predicate.type === 'boolean'\n        ? left.toLowerCase() === 'true'\n        : left;\n    const normalizedRights =\n      typeof rights === 'string' && predicate.type === 'boolean'\n        ? rights.toLowerCase() === 'true'\n        : rights;\n\n    return normalizedLeft != normalizedRights && !Number.isNaN(normalizedLeft);\n  }\n\n  if (predicate.operator === 'less_than') {\n    return !Number.isNaN(Number(left)) && Number(left) < Number(rights);\n  }\n\n  if (predicate.operator === 'greater_than') {\n    return Number(left) > Number(rights) && !Number.isNaN(Number(left));\n  }\n\n  if (predicate.operator === 'between') {\n    if (!Array.isArray(rights))\n      throw new RuleExecutionError(\n        `Rule Execution failed. Failed to extract bounds of rule ${predicate.right}`\n      );\n    const min = rights[0];\n    const max = rights[1];\n    return Number(left) >= Number(min) && Number(left) <= Number(max);\n  }\n\n  if (predicate.operator === 'outside') {\n    if (!Array.isArray(rights))\n      throw new RuleExecutionError(\n        `Rule Execution failed. Failed to extract bounds of rule ${predicate.right}`\n      );\n    const min = rights[0];\n    const max = rights[1];\n\n    return Number(left) < Number(min) || Number(left) > Number(max);\n  }\n\n  if (predicate.type === 'matrix') {\n    assertIsMatrix(rights);\n\n    const leftLower = typeof left === 'string' ? left.toLowerCase() : left;\n    const match = rights.some((row) =>\n      row.some((cell) => cell.trim().toLowerCase() === leftLower)\n    );\n\n    if (predicate.operator === 'is_in') return match;\n    if (predicate.operator === 'is_not_in') return !match;\n  }\n\n  throw new RuleExecutionError(\n    `Rule Execution failed for predicate ${JSON.stringify(predicate)}.`\n  );\n}\n","import { executePredicate } from '../../predicate';\n\nimport type { SpektrData } from '../../../validators/data';\nimport type { LogicalField } from '../../../validators/fields/Field';\nimport type { Predicate } from '../../../validators/rules/predicate';\nimport { ConditionOutput } from '../../../validators/fields/ConditionalField';\n\n/**\n * @description\n *   Evaluates a logical field based on its segment groups and context data.\n *  Based on the desired output (show/hide), it determines if the field should be displayed.\n *\n * @param field Field to be evaluated\n * @param context Context data used for evaluation\n * @returns If the field should be shown or not\n */\nexport function evaluateLogicalField(\n  field: LogicalField,\n  context: SpektrData\n): boolean {\n  if (!field?.segment) {\n    return false;\n  }\n\n  if (\n    !Array.isArray(field.segment?.groups) ||\n    field.segment.groups.length === 0\n  ) {\n    return false;\n  }\n\n  const evaluation = field.segment.groups\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map((group: any) =>\n      executePredicate(group.rule as Predicate, context, context)\n    )\n    .every((result: boolean) => !!result);\n\n  const shouldShow =\n    field.output === ConditionOutput.Enum.show ? evaluation : !evaluation;\n\n  return shouldShow;\n}\n","import { hasLogicalFields } from './utils/hasLogicalFields';\nimport { orderFields } from '../../utils/orderFields';\nimport { SpektrData } from '../../validators/data';\n\nimport { isLogicalField, type Field } from '../../validators/fields/Field';\nimport type { Form } from '../../validators/fields/Form';\n\nimport { evaluateLogicalField } from './utils/evaluateLogicalField';\n\nexport function formEvaluation(field: Form, context: SpektrData): Field[] {\n  if (!hasLogicalFields(field.fields)) {\n    return orderFields(field.fields, field.order);\n  }\n\n  const evaluatedFields: Field[] = [];\n\n  orderFields(field.fields, field.order).forEach((field) => {\n    if (isLogicalField(field)) {\n      const shouldShow = evaluateLogicalField(field, context);\n\n      if (shouldShow) {\n        evaluatedFields.push(\n          ...orderFields(field.form.fields, field.form.order)\n        );\n      }\n\n      return;\n    }\n\n    evaluatedFields.push(field);\n  });\n\n  return evaluatedFields;\n}\n","export const SUPPORTED_LANGUAGES = [\n  'en-US', // English (United States)\n  'da-DK', // Danish (Denmark)\n  'sv-SE', // Swedish (Sweden)\n  'no-NO', // Norwegian (Norway)\n  'fi-FI', // Finnish (Finland)\n  'de-DE', // German (Germany)\n  'fr-FR', // French (France)\n  'es-ES', // Spanish (Spain)\n  'it-IT', // Italian (Italy)\n  'pt-PT', // Portuguese (Portugal)\n  'nl-NL', // Dutch (Netherlands)\n  'pl-PL', // Polish (Poland)\n] as const;\n","import { SUPPORTED_LANGUAGES } from '../constants/supportedLanguages';\n\nexport function isLocaleSupported(locale: string): boolean {\n  // Check if the locale is in the list of supported languages\n  return SUPPORTED_LANGUAGES.includes(\n    locale as (typeof SUPPORTED_LANGUAGES)[number]\n  );\n}\n","import { produce } from 'immer';\n\nimport { getNaceCodesUrl } from '../../../utils/cdn';\n\nimport { type DropdownField } from '../../../validators/fields/DropdownField';\nimport { type NaceCode } from '../../../types/NaceCode';\n\nexport async function translateNaceCodes(\n  field: DropdownField,\n  language: string\n): Promise<DropdownField> {\n  const naceCodes = (await fetch(getNaceCodesUrl(language)).then((res) =>\n    res.json()\n  )) as NaceCode[];\n\n  if (!Array.isArray(naceCodes)) {\n    throw new Error(`NACE codes not found for language: ${language}`);\n  }\n\n  const updatedOptions = naceCodes.map((code) => {\n    const value = `${code.section}${code.code}`;\n    let label = `${value} - ${code.name}`;\n\n    if (code.level && Number(code.level) > 1) {\n      label += ` (${code.level})`;\n    }\n\n    return { value, label };\n  });\n\n  return produce(field, (draft) => {\n    draft.attributes.options = updatedOptions;\n  });\n}\n","const ORIGIN = 'https://platform.spektr.com/';\n\nexport function getNaceCodesUrl(language: string): string {\n  const url = new URL(`assets/data/${language}/nace-codes.json`, ORIGIN);\n  return url.toString();\n}\n","import { isLocaleSupported } from '../../utils/isLocaleSupported';\n\nimport { isLogicalField, type Field } from '../../validators/fields/Field';\nimport { isDropdownField } from '../../validators/fields/DropdownField';\n\nimport { translateNaceCodes } from './utils/translateNaceCodes';\nimport { isEntitiesField } from '../../validators/fields/EntitiesField';\n\nexport async function translateFields(\n  fields: Record<string, Field>,\n  language?: string\n) {\n  let typedLanguage = 'en-US';\n  if (language && isLocaleSupported(language)) {\n    typedLanguage = language;\n  }\n\n  const result: Record<string, Field> = {};\n\n  for (const [key, field] of Object.entries(fields)) {\n    if (isEntitiesField(field) || isLogicalField(field)) {\n      const translatedFields = await translateFields(\n        field.form.fields,\n        typedLanguage\n      );\n\n      result[key] = {\n        ...field,\n        form: {\n          ...field.form,\n          // Because the `fields` property is defined separate of Field,\n          // we need to cast it to `any` to avoid TypeScript errors.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fields: translatedFields as any,\n        },\n      };\n    } else if (\n      isDropdownField(field) &&\n      field.config.spektrDataField === 'nace_code'\n    ) {\n      const newField = await translateNaceCodes(field, typedLanguage);\n      result[key] = newField;\n    } else {\n      result[key] = field;\n    }\n  }\n\n  return result;\n}\n","import { formEvaluation } from './lib/formEvaluation';\nimport { evaluateLogicalField } from './lib/formEvaluation/utils/evaluateLogicalField';\nimport { executePredicate } from './lib/predicate';\nimport { translateFields } from './lib/translations';\n\nexport const SpektrSdk = {\n  executePredicate,\n  formEvaluation,\n  translateFields,\n  evaluateConditionalField: evaluateLogicalField,\n};\n\nexport default SpektrSdk;\n"],"mappings":"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","names":["index_exports","__export","SpektrSdk","SpektrSdk_default","__toCommonJS","import_zod","import_zod","import_zod","FieldConfig","FieldUiConfig","BaseField","FieldConfig","FieldUiConfig","import_zod","validationTypes","validationTypesEnum","RequiredFieldValidation","RegexFieldValidation","DateFieldValidation","FieldValidation","import_zod","InputFieldAttributes","InputField","BaseField","FieldValidation","import_zod","DropdownFieldAttributes","DropdownField","BaseField","FieldValidation","isDropdownField","field","import_zod","CheckboxFieldAttributes","CheckboxField","BaseField","FieldValidation","import_zod","FileFieldAttributes","FileField","BaseField","FieldValidation","import_zod","DateFieldAttributes","InputFieldAttributes","DateField","InputField","import_zod","CurrencyFieldAttributes","InputFieldAttributes","CurrencyField","InputField","import_zod","TitleField","FieldUiConfig","import_zod","ParagraphField","FieldUiConfig","import_zod","DividerField","FieldUiConfig","import_zod","ConsentFieldAttributes","ConsentField","BaseField","FieldValidation","import_zod","SmartFieldAttributes","SmartField","BaseField","FieldValidation","import_zod","InformationCalloutField","FieldUiConfig","import_zod","FieldsGroup","FieldUiConfig","import_zod","outputTypes","ConditionOutput","ConditionalField","BaseField","FieldValidation","DateField","CurrencyField","InputField","DropdownField","CheckboxField","FileField","TitleField","ParagraphField","InformationCalloutField","FieldsGroup","DividerField","ConsentField","SmartField","EntitiesField","BaseField","FieldValidation","DateField","CurrencyField","InputField","DropdownField","CheckboxField","FileField","TitleField","ParagraphField","InformationCalloutField","FieldsGroup","DividerField","ConsentField","SmartField","ConditionalField","isEntitiesField","field","import_zod","LogicalField","ConditionalField","isLogicalField","field","ReadOnlyField","TitleField","ParagraphField","InformationCalloutField","FieldsGroup","DividerField","WritableField","DateField","CurrencyField","InputField","DropdownField","CheckboxField","FileField","EntitiesField","ConsentField","SmartField","Field","ReadOnlyField","WritableField","LogicalField","hasLogicalFields","fields","field","isLogicalField","isEntitiesField","orderFields","fields","order","orderedFields","fieldId","rangeRegex","parseRange","range","_a","_b","match","rangeRegex","min","max","iso","parseCountry","countryIdentifier","identifierType","countryInfo","parseEpochDate","date","ms","parseDdMmYyyyDate","date","regex","match","_","dayString","monthString","yearString","day","month","year","utcDate","parseYyyyMmDdDate","date","regex","match","_","yearString","monthString","dayString","year","month","day","import_date_fns","parseIso8601Date","date","dateInUtc","parsed","parseTimestampString","date","parseDate","date","parsers","parseTimestampString","parseDdMmYyyyDate","parseYyyyMmDdDate","parseIso8601Date","parseEpochDate","parser","parsed","parseDateToTimestamp","value","ensureMilliseconds","parsedDate","timestamp","RuleExecutionError","message","assertIsMatrix","matrix","RuleExecutionError","row","cell","epochOrTodayToEpoch","epochOrToday","import_zod","import_zod","SpektrFieldType","booleanPredicateSchema","SpektrFieldType","predicateSchema","equalityPredicateSchema","SpektrFieldType","inequalityPredicateSchema","SpektrFieldType","rangePredicateSchema","SpektrFieldType","rangeRegex","IsRelativeToDatePositions","IsRelativeToDateScopes","datePositionSchema","dateScopeSchema","dateAfterBeforeSchema","SpektrFieldType","dateRelativeToTodaySchema","dateComparisonPredicateSchema","existencePredicateSchema","SpektrFieldType","matrixPredicateSchema","noOpPredicateSchema","containsPredicateSchema","predicateSchema","booleanPredicateSchema","equalityPredicateSchema","inequalityPredicateSchema","rangePredicateSchema","dateComparisonPredicateSchema","existencePredicateSchema","matrixPredicateSchema","noOpPredicateSchema","containsPredicateSchema","calculateDayPeriod","today","position","quantity","todayYear","todayMonth","todayDate","IsRelativeToDatePositions","pastDayStart","pastDayEnd","nextDayStart","nextDayEnd","calculateMonthPeriod","today","position","quantity","currentYear","currentMonth","startMonthOffset","endMonthOffset","startDay","endDay","IsRelativeToDatePositions","start","end","calculateWeekPeriod","today","position","quantity","todayYear","todayMonth","todayDate","currentDay","sunOfWeek","startOffset","endOffset","IsRelativeToDatePositions","start","end","calculateYearPeriod","today","position","quantity","currentYear","startYearOffset","endYearOffset","IsRelativeToDatePositions","start","end","calculateRelativePeriod","position","scope","quantity","now","today","IsRelativeToDateScopes","calculateDayPeriod","calculateWeekPeriod","calculateMonthPeriod","calculateYearPeriod","isDateInRelativePeriod","dateEpoch","config","position","scope","quantity","start","end","calculateRelativePeriod","date","normalizedDate","dateCompareAgainst","leftEpoch","rightEpochOrToday","rightEpoch","epochOrTodayToEpoch","isRelativeConfig","isDateInRelativePeriod","getRights","predicate","subs","_a","min","max","parseRange","RuleExecutionError","right","executePredicate","predicate","leftSubs","rightSubs","leftEvaluated","rightEvaluated","RuleExecutionError","left","rights","getRights","leftEpoch","parseDateToTimestamp","spektrFieldDate","dateCompareAgainst","leftCountry","parseCountry","match","right","rightCountry","arrayLeft","_e","rightsSet","leftItem","parsedLeft","normalizedLeft","normalizedRights","min","max","assertIsMatrix","leftLower","row","cell","evaluateLogicalField","field","context","_a","evaluation","group","executePredicate","result","ConditionOutput","formEvaluation","field","context","hasLogicalFields","orderFields","evaluatedFields","isLogicalField","evaluateLogicalField","SUPPORTED_LANGUAGES","isLocaleSupported","locale","SUPPORTED_LANGUAGES","import_immer","ORIGIN","getNaceCodesUrl","language","translateNaceCodes","field","language","naceCodes","getNaceCodesUrl","res","updatedOptions","code","value","label","draft","translateFields","fields","language","typedLanguage","isLocaleSupported","result","key","field","isEntitiesField","isLogicalField","translatedFields","isDropdownField","newField","translateNaceCodes","SpektrSdk","executePredicate","formEvaluation","translateFields","evaluateLogicalField","SpektrSdk_default"]}